<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java Collection Framework - Outline]]></title>
    <url>%2F2018%2F05%2F14%2FJava-Collection-Framework-Outline%2F</url>
    <content type="text"><![CDATA[这是一篇oracle官方对Java集合框架的大纲的翻译，点击可查看原文 具体的思维导图已经在简介中给出了。 以下为翻译： 集合框架大纲集合框架主要包含： 集合接口 Collection 一组对象的集合.没有规定集合的有序也没有规定是否可以包含相同的元素。 Set 就是广义上的集合，规定了不能包含相同的元素，继承自Collection接口，有序和没序都有可能。 List 继承自Collection接口，有序的集合或者说是一连串数据集合. 允许元素重复，允许通过元素下标索引。 Queue 用于存放等待处理流程前的数据的容器，除了基础的Collection接口方法外，queues提供了额外的插入，提取和检查等操作。 Deque 一个双端队列继承自Queue接口，支持从任意一端的插入和删除操作。 Map 一种键和值的数据映射结构，每个键都对应唯一的值。 SortedSet 继承自Set接口，一个元素自动排序的Set集合，排序方式使用自然顺序或创建SortedSet实例时提供Comparator对象。 SortedMap 继承自Map接口，一个通过key自动排序的Map结构，排序方式使用自然顺序或创建SortedMap实例时提供Comparator对象。 NavigableSet 在一个SortedSet上添加了一个为搜索目标获取最接近的匹配项的方法。可以升序或降序的访问遍历整个NavigableSet。 NavigableMap 在一个SortedMap上添加了一个为搜索目标获取最接近的匹配项的方法。可以升序或降序的访问遍历整个NavigableMap。 BlockingQueue 扩展Queue接口，当队列为空时获取队列元素会发生阻塞，当队列为满时添加队列元素会发生阻塞。 TransferQueue 扩展BlockingQueue接口，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费。 BlockingDeque 扩展Deque，BlockingQueue接口，当双向队列为空时获取队列元素会发生阻塞，当双向队列为满时添加队列元素会发生阻塞。 ConcurrentMap 一个添加了原子性的putIfAbsent，remove, replace操作的Map。 ConcurrentNavigableMap 集合了ConcurrentMap和NavigableMap的特性。 多用途接口实现 HashSet 用哈希表扩展Set接口的实现，最全面的Set接口实现。 TreeSet NavigableSet的红黑树实现。 LinkedHashSet Set接口的链表和哈希表实现，一个和HashSet效率相似的有序输入Set实现。 ArrayList 一个实现了list接口(不同步的Vector)可重新规划大小的数组。list接口最佳实现。 ArrayDeque 高效切可重新规划大小的Deque接口的数组实现。 LinkedList 双重链表实现List接口，对比ArrayList的LinkedList的实现再处理频繁元素插入和删除操作时效率更高，同时实现了Deque接口，当通过Queue使用时，LinkedList表现为一个FIFO队列。 PriorityQueue 无界优先级队列的堆实现。 HashMap Map接口的哈希表实现(一个支持null键值的非线程同步的Hashtable)Map接口的最佳实现。 TreeMap NavigableMap接口的红黑树实现。 LinkedHashMap Map接口的哈希表和双重链表实现。一个效率和HashMap类似的输入有序的Map实现。在实在缓存功能这种数据结构是很有用。 包装实现类对某些集合的实现增加一些功能特性，完全是通过静态工厂方法创建 Collections.unmodifiableInterface 返回一个当前集合的不可修改的集合，如果用户想要修改集合内元素就会抛出一个UnsupportedOperationException。 Collections.synchronizedInterface 返回一个依赖当前非线程同步集合的线程同步的集合。 Collections.checkedInterface 返回一个对应动态类型检测的集合，如果客户端想要添加一个错误类型的type会抛出一个ClassCastException异常，一般的程序都会提供语言层的静态类型检测，不过这种静态类型的检测是可以绕开的，而动态的类型检测消除了这种危险性。 适配器接口实现适配一个集合的实现到另一个实现。 newSetFromMap(Map) 从一个通用Map实现创建一个通用的Set实现 asLifoQueue(Deque) 返回一个Deque单具有后入先出队列的实现 便捷实现集合接口的高性能的便捷实现。 Arrays.asList 让一个数组具有list的实现。 emptySet, emptyList 和 emptyMap 返回一个永远不变的空Set，空List或空Map。 singleton, singletonList 和 singletonMap 返回一个永远不变的单例的 set, list, 或map，只包含特定的对象(或者键-值)。 nCopies 返回一个永远不变list包含N个指定对象的拷贝。 遗留实现老的集合类翻新成被新的实现 Vector List接口的线程同步和可重新拓展大小数组的实现，包含了遗留的一些方法。 Hashtable Map接口的线程同步的的哈希表实现，不允许null的键或值，包含了遗留的一些方法。 特殊目的实现 WeakHashMap 一个只储存键的虚引用的Map实现，只存储键的虚引用让java垃圾收集器可以回收那些在WeakHashMap外部不再有引用的键值对。这是类是对虚引用特性最简单的运用，它对于实现注册表类似的数据结构非常有用，因为当一个条目的键不再被任何线程访问时，它的键就可以被消除了。 IdentityHashMap 基于哈希表的身份Map，这个类在用于对象拓扑图的转换时很有用(类似序列化或深拷贝)要执行这些转换，您必须维护一个基于身份的“节点表”，它跟踪哪些对象已经被看到了。IdentityHashMap也被用于维护对象的元信息映射动态调试器和其他类似系统中。最后IdentityHashMap在防止蓄意欺骗equal()造成的“欺骗攻击”方面很有用(IdentityHashMap从不对内部的key调用equal()方法)，还有一个额外的好处这个实现执行效率很高。 CopyOnWriteArrayList 一个copy-on-write数组的列表实现，所有的修改操作（如添加、设置、删除）都是通过生成一个新的数组复制来实现。不需要线程同步，即使是在迭代中迭代器也绝不会抛出ConcurrentModificationException。此实现非常适合维护事件处理列表（其中更改很少，遍历频繁且可能耗时）。 CopyOnWriteArraySet 基于copy-on-write数组的Set实现，这个实现和CopyOnWriteArrayList类似，与大多数set实现不同的是，添加、删除和包含方法需要时间与集合的大小成比例。此实现非常适合维护必须防止重复的事件处理列表。 EnumSet 一种基于Bit Vector的高性能集合实现，每一个EnumSet实例的所有元素都必须是一个枚举类型。 EnumMap 一种基于数组的高性能Map实现，每一个EnumMap实例的所有键必须是一个枚举类型。 并行实现 ConcurrentLinkedQueue 基于链接节点的无边界先入先出队列。 LinkedBlockingQueue 一个可选的基于链接节点的有界FIFO阻塞队列。 ArrayBlockingQueue 基于数组的有界FIFO阻塞队列。 PriorityBlockingQueue 基于优先级堆的无界阻塞优先级队列。 DelayQueue 基于优先级堆的时间调度队列。 SynchronousQueue 一个简单的会合机制BlockingQueue接口实现。 LinkedBlockingDeque 一个可选的基于链接节点的有界FIFO阻塞双向队列实现。 LinkedTransferQueue 一个基于链接节点的无界TransferQueue实现。 ConcurrentHashMap 一个基于哈希表的高性能并发并且高性能的ConcurrentMap实现，此实现在执行检索时不会阻塞，并且允许客户端选择更新的并发级别。ConcurrentHashMap被考虑为Hashtable的一个简单代替品，除了实现ConcurrentMap功能以外，它还支持所有哈希表的传统方法。 ConcurrentSkipListSet NavigableSet接口的跳跃表实现。 ConcurrentSkipListMap ConcurrentNavigableMap接口的跳跃表实现。 抽象实现 AbstractCollection 抽象Collection实现表示既不是Set也不是List(类似一个bag或者multiset)。 AbstractSet 抽象Set实现。 AbstractList 基于随机访问数据存储（如array）的抽象List实现。 AbstractSequentialList 基于顺序访问数据存储（如链表）的抽象List实现。 AbstractQueue 抽象Queue实现。 AbstractMap 抽象Map实现。 算法 Collections类包含这些有用的静态方法。 sort(List) 使用归并排序对列表进行排序，它的性能平均情况下的相当于一个高质量的快速排序，保证O(n*logn)的性能(快速排序不能保证)，稳定(快速排序是不稳定的)。稳定排序是不重排相等元素的排序。 binarySearch(List, Object) 在有序列表中通过二分查找算法寻找对应元素。 reverse(List) 翻转一个列表的元素顺序。 shuffle(List) 随机修改列表元素的顺序。 fill(List, Object) 用对应的元素覆盖列表中的每一个元素。 copy(List dest, List src) 拷贝源列表到目标列表。 min(Collection) 返回集合内最小的元素。 max(Collection) 返回集合内最大的元素。 rotate(List list, int distance) 按指定的距离旋转列表中的所有元素。 replaceAll(List list, Object oldVal, Object newVal) 用另一个指定值替换所有出现的值。 indexOfSubList(List source, List target) 返回第一个符合子列表的索引下标。 lastIndexOfSubList(List source, List target) 返回最后一个符合子列表的索引下标。 swap(List, int, int) 交换指定列表中指定位置的元素。 frequency(Collection, Object) 计算指定元素在指定集合中出现的次数。 disjoint(Collection, Collection)确定两个集合是否是不相交的，换句话说，它们是否不包含公共元素。 addAll(Collection&lt;? super T&gt;, T…) 将指定数组中的所有元素添加到指定集合中。 基础架构 Iterators 类似我们熟悉的Enumeration接口，但是更为强大，并且优化了命名 Iterator 除了包含Enumeration接口的功能之外，还允许用户在具有良好定义的语义层面的集合中移除元素。 ListIterator 列表中使用的迭代器，除了包含迭代器接口的功能外，还支持双向迭代、元素替换、元素插入和索引检索功能。 Ordering Comparable 如果要实现自然排序功能你需要实现这个接口，自然排序可用于排序列表或维护排序的集合或映射中的顺序，java中很多类都实现了Comparable接口。 Comparator 表示顺序关系，可用于排序列表或维护排序的集合或映射中的顺序。可以不通过实现Comparable接口的同事重写某个类型的自然排序或对象顺序。 Runtime exceptions UnsupportedOperationException 当集合调用某些不支持的操作是会抛出这个异常。 ConcurrentModificationException 当用iterators或list iterators在迭代集合元素的时候集合元素发生意外更改时会抛出此异常，同样的当子列表发生类似的意外更改时也会抛出此异常。 性能 RandomAccess 这是一个标记接口，代表实现这个接口的List支持快速的(通常为固定时间的)随机访问机制，这个接口往往会改变当前的随机或者是顺序访问集合的某些算法行为来优化效率。 数组工具 Arrays 包含排序、搜索、比较、散列、复制、调整大小、转换为字符串，填充对象数组等静态方法。]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>Java Collection Framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Java Collection Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Collection Framework - Introduction]]></title>
    <url>%2F2018%2F05%2F14%2FJava-Collection-Framework-Introduction%2F</url>
    <content type="text"><![CDATA[Java Collection Framework 是Java类库中最为重要的基础组件之一，主要作用是简化开发者对数据结构操作的难度，并集合了一系列优秀并且常用的数据结构，包括List、Set、Map、Stack、Queue等数据结构和其派生，并且在处理某些场景时优化了部分方法的执行效率，并且随着Java的版本升级更多优秀的方法也会被加入到库中来。 以下整理的是Collection框架中的接口和类的思维导图：从图中可以看到接口部分主要是抽象了这种集合的规范，而类的部分是一个从Abstract类到最终实体类的演变过程，包括队列(Queue),双向队列(Deque),列表(List),栈(Stack),链表(LinkedList),集合(Set),表(table),地图集(Map),字典集(Dictionary)等等，以及Concurrent包下的适用于多线程的数据结构。 之后的文章会对Collection框架中的大部分接口和类进行一个解析，包括Api使用、注意事项以及源码的解析。]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
        <category>Java Collection Framework</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Java Collection Framework</tag>
      </tags>
  </entry>
</search>
